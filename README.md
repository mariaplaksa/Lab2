## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2501`

#### Выполнила: `Плакса Мария Антоновна`

#### Вариант: `15`

### Cодержание:

- Постановка задачи
- Входные и выходные данные
- Алгоритм
- Программа
- Анализ правильности решения

### 1. Постановка задачи
Задача 1.
> Ваша задача – посмотреть, какие значения принимает последовательность при разных a0 и n, вывести закономерность, по которой строится последовательность и запрограммировать ее самостоятельно.
>Ограничение сверху на n – искусственное, чтобы не упал весь сайт (а вы можете выбрать любое разумное ограничение самостоятельно). Если на ваш запрос сервер пятисотит (HTTP 500), значит ваша последовательность быстро растет, и питон сломался обрабатывать ее элементы, попробуйте вывести еще меньше элементов.

Для решения данной задачи необходимо проанализировать последовательность при разных a0 и n и вывести закономерность.

Задача 2.
>Дана последовательность из n целых чисел. Найти самую длинную подпоследовательность равных по модулю элементов, идущих подряд. Вывести ее длину и индекс первого элемента. Если таких подпоследовательностей несколько, выбрать ту, в которой знаки чисел чередуются (+ – + – или – + – +) дольше всего. Если и таких несколько, выбрать ту, которая встречается раньше остальных.

Для решения данной задачи необходимо проанализировать последовательность целых чисел и найти самую длинную непрерывную подпоследовательность элементов, равных по модулю. Для реализации необходимо совершить однократный проход по массиву с отслеживанием текущей подпоследовательности, удовлетворяющей условию равенства модулей. Одновременно отслеживается чередование знаков.

Задача 3.
>С клавиатуры вводится натуральное число N. Вывести на экран количество нечетных цифр в десятичном представлении числа.

Для решения данной задачи необходимо определить, сколько нечётных цифр содержится в десятичной записи натурального числа N , введённого с клавиатуры. Для этого будем последовательно извлекать цифры из числа и проверять на четность.

Задача 4.
>Дана возрастающая последовательность из n различных целых чисел. Требуется разбить её на непересекающиеся отрезки так, чтобы все числа из данной последовательности были покрыты этими отрезками ровно один раз, и чтобы не существовало числа, которое попало бы в какой-либо отрезок, но отсутствовало в исходной последовательности. Если отрезок содержит одно число – выведите только его, а если несколько – выведите границы через дефис (start-finish).

Для решения данной задачи необходимо группировать подряд идущие целые числа из заданной возрастающей последовательности в непрерывные отрезки, просмотреть последовательность и объединить в один отрезок те числа, которые образуют сплошной числовой интервал. Как только обнаруживается разрыв — то есть текущее число не следует сразу за предыдущим, — текущий отрезок завершается и начинается новый.

### 2. Входные и выходные данные

#### Данные на вход

Задача 1.

На вход программа должна получать 1 целое число и 1 натуральное число.

|             | Тип                       |min значение     | max значение   |
|-------------|---------------------------|-----------------|----------------|
| a0 (Число 1)| Целое  число              |-2<sup>31</sup>  |2<sup>31</sup>-1|
| n (Число 2) | Целое положительное число | 1               |99              |

Задача 2.

На вход программа должна получать сначала натуральное число n, затем n целых чисел.

|             | Тип                       |min значение     | max значение   |
|-------------|---------------------------|-----------------|----------------|
| n (Число 1) | Целое положительное число |1                |2<sup>31</sup>-1|
| n чисел     | Целое               число |-2<sup>31</sup>  |2<sup>31</sup>-1|

Задача 3.

На вход программа должна получать натуральное число N.

|             | Тип                       |min значение     | max значение   |
|-------------|---------------------------|-----------------|----------------|
| N           | Целое положительное число |1                |2<sup>31</sup>-1|

Задача 4.

На вход программа должна получать сначала натуральное число n, затем n целых чисел.

|             | Тип                       |min значение     | max значение   |
|-------------|---------------------------|-----------------|----------------|
| n (Число 1) | Целое положительное число |1                |2<sup>31</sup>-1|
| n чисел     | Целое               число |-2<sup>31</sup>  |2<sup>31</sup>-1|

#### Данные на выход

Задача 1.

На выход мы получим последовательность из n чисел.

|              | Тип                       | min значение  | max значение   |
|--------------|---------------------------|---------------|----------------|
| n целых чисел| Целое               число |-2<sup>31</sup>|2<sup>31</sup>-1|

Задача 2.

|             | Тип                       |min значение     | max значение   |
|-------------|---------------------------|-----------------|----------------|
|bestlenght   | Целое положительное число |1                |2<sup>31</sup>-1|
|beststart    | Целое               число |0                |2<sup>31</sup>-1|

Задача 3.

|              | Тип                       | min значение  | max значение   |
|--------------|---------------------------|---------------|----------------|
|с             | Целое               число |0              |2<sup>31</sup>-1|

Задача 4.

На выход мы получаем либо целые числа, либо отрезок: границы через дефис.

### 3. Алгоритм

#### Алгоритм выполнения программы:

Задача 1.

1. **Ввод данных**  

   Программа считывает 2 целых числа.
   a0 — начальное значение последовательности; 
   n — количество элементов, которые необходимо вывести

2. **Вычисление и вывод первого элемента**  

   Программа создает пременную, обозначенную как `x`, и присваивает ей начальное значение, равное `a0 * (-3)`. Это будет первый член последовательности, который сразу выводится.

3. **Генерация остальных n−1 элементов**

   Начинаем цикл for. Для каждого последующего элемента (от индекса 1 до n−1 ) применяется условный оператор  if:
    если индекс i нечётный (i%2 не равно 0), то к текущему значению x прибавляется −2;
    если индекс i чётный, то текущее значение x умножается на −3.

4. **Последовательный вывод**

   Каждый вычисленный элемент сразу выводится на экран с пробелом после него. 

Задача 2.

1. **Ввод данных**  

   Программа считывает натуральное число n — длину последовательности, а затем n целых чисел, которые сохраняются в массив a.

2. **Инициализация переменных для отслеживания подпоследовательностей**  

   start, lenght, alt — описывают текущую рассматриваемую подпоследовательность:
   start — индекс её начала; 
   lenght — её длина;
   alt — длина участка этой подпоследовательности, на котором знаки элементов чередуются.
   beststart, bestlenght, bestalt — хранят параметры наилучшей подпоследовательности, найденной к текущему моменту.

3. **Проход по массиву с расширением или завершением текущей подпоследовательности**

   Цикл for проходит от индекса 1 до n (включительно), чтобы обработать завершение последней группы.
   Если текущий элемент существует (i < n) и его модуль равен модулю первого элемента текущей подпоследовательности (a[start]), то подпоследовательность продолжается:
   её длина увеличивается на 1.
   Если до текущего элемента чередование знаков сохранялось полностью (alt == lenght - 1), и знаки соседних элементов различны (a[i-1] * a[i] < 0 при условии, что оба ненулевые), то счётчик чередования alt увеличивается.
   В противном случае (модули различаются или достигнут конец массива) текущая подпоследовательность завершается.

4. **Сравнение завершённой подпоследовательности с лучшей найденной**

   При завершении подпоследовательности она сравнивается с текущей наилучшей:
   если её длина больше — она становится новой наилучшей;
   если длины равны, но у текущей больше длина чередования знаков (alt > bestalt) — она также заменяет наилучшую.
   При равенстве — сохраняется первая (так как замена происходит только при строгом улучшении).

5. **Начало новой подпоследовательности**

   После завершения текущей (если ещё не конец массива) начинается новая подпоследовательность с текущего индекса i.

6. **Вывод результата**

   По окончании цикла программа выводит длину наилучшей подпоследовательности (bestlenght) и индекс её первого элемента (beststart) — с нумерацией с нуля.

Задача 3.

1. **Ввод данных**  

   Программа считывает с клавиатуры натуральное число n.

2. **Инициализация счётчика**  

   Переменная `c` инициализируется нулём и будет использоваться для подсчёта количества нечётных цифр в числе n.
Переменная `x` создаётся и принимает значение n, чтобы исходное значение не изменялось.

3. **Обработка цифр числа справа налево**

   С помощью цикла while программа последовательно извлекает цифры числа x, начиная с младшего разряда:
   остаток от деления x % 10 даёт последнюю цифру.
   Если эта цифра нечётная (проверка (x % 10) % 2 == 1), счётчик c увеличивается на 1.
   Затем число x целочисленно делится на 10, отбрасывая обработанную цифру. Цикл продолжается до тех пор, пока все цифры не будут обработаны, то есть пока x не станет равным нулю.

4. **Вывод результата**

   После завершения цикла программа выводит значение счётчика `c` — общее количество нечётных цифр в десятичной записи исходного числа n.

Задача 4.

1. **Ввод данных**  

   Программа считывает натуральное число n — длину последовательности, а затем n целых чисел, которые сохраняются в массив a.

2. **Инициализация начала текущего отрезка**  

   Переменная start устанавливается в 0 и указывает на индекс первого элемента текущего непрерывного отрезка.

3. **Проход по последовательности для выявления разрывов**

   Цикл начинается со второго элемента (i = 1). На каждом шаге проверяется выполняется ли условие a[i] == a[i - 1] + 1. Если это не так, значит, текущий отрезок завершается на предыдущем элементе (i - 1).

4. **Вывод завершённого отрезка**

   Если отрезок состоит из одного элемента (start == i - 1), выводится само это число. Если отрезок содержит несколько элементов, выводятся его границы в формате начало-      конец.
   После вывода текущий отрезок завершается, и start устанавливается на индекс i, обозначая начало нового отрезка.

5. **Вывод последнего отрезка**

   После завершения цикла остаётся последний отрезок — от start до конца массива (n - 1). Он выводится по тем же правилам.

### 4. Программа

 Задача 1.
 
```java
import java.io.PrintStream;
import java.util.Scanner;
public class Task1 {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args)  {
        int a0 = in.nextInt();
        int n = in.nextInt();
        int x = a0 * (-3);
        out.print(x + " ");
        for (int i = 1; i < n; i++) {
            if (i % 2 != 0) {
                x = x - 2;
                out.print(x + " ");
            }
            else{
                x = x * (-3);
                out.print(x + " ");
            }
        }
    }
}
```
Задача 2.

```java
import java.io.PrintStream;
import java.util.Scanner;
public class Task2 {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;
    public static void main(String[] args) {
        int n = in.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
        }
        int bestlenght = 1;
        int beststart = 0;
        int bestalt = 1;
        int start = 0;
        int lenght = 1;
        int alt = 1;
        for (int i = 1; i <= n; i++) {
            if ((i < n) && (Math.abs(a[i]) == Math.abs(a[start]))) {
                lenght++;
                if (alt == lenght - 1) {
                    if (a[i - 1] != 0 && a[i] != 0 && a[i - 1] * a[i] < 0) {
                        alt++;
                    }
                }
            } else {
                if (lenght > bestlenght ||
                        (lenght == bestlenght && alt > bestalt)) {
                    bestlenght = lenght;
                    beststart = start;
                    bestalt = alt;
                }
                if (i < n) {
                    start = i;
                    lenght = 1;
                    alt = 1;
                }
            }
        }
        out.println(bestlenght);
        out.println(beststart);
    }
}
```

Задача 3.

```java
import java.io.PrintStream;
import java.util.Scanner;
public class Task3 {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) {
        int n = in.nextInt();
        int c = 0;
        int x = n;
        while (x > 0) {
            if ((x % 10) % 2 == 1) {
                c++;
            }
            x /= 10;
        }
        out.println(c);
    }
}
```

Задача 4.

```java
import java.io.PrintStream;
import java.util.Scanner;
public class Task4 {
    public static Scanner in = new Scanner(System.in);
    public static PrintStream out = System.out;

    public static void main(String[] args) {
        int n = in.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = in.nextInt();
        }
        int start = 0;
        for (int i = 1; i < n; i++) {
            if (a[i] != a[i - 1] + 1) {
                if (start == i - 1) {
                    out.print(a[start]);
                    out.print(" ");
                } else {
                    out.print(a[start] + "-" + a[i - 1]);
                    out.print(" ");
                }
                start = i;
            }
        }
        if (start == n - 1) {
            System.out.print(a[start]);
        } else {
            System.out.print(a[start] + "-" + a[n - 1]);
        }
    }
}
```
### 6. Анализ правильности решения

Задача 1.

Input:
1 5

Output:
-3 -5 15 13 -39 

Задача 2.

   1. Тест: все элементы равны по модулю и чередуются.

Input:
5
3 -3 3 -3 3

Output:
5
0

   2. Тест: несколько подпоследовательностей равной длины, но разное чередование.

Input:
6
2 -2 2 5 -5 5

Output:
3
0

   3. Тест: несколько групп, разные длины.

Input:
7
1 2 -2 2 3 -3 -3

Output:
3
1

   4. Тест: две группы одинаковой длины и одинакового alt, выбирается первая.

Input:
8
5 5 -5 -5 4 4 -4 -4

Output:
4
0

Задача 3.

1. Тест: все цифры нечётные.

Input:
13579

Output:
5

   2. Тест: все цифры чётные.

Input:
2468

Output:
0

   3. Тест: смешанные цифры.

Input:
10203

Output:
2

Задача 4.

   1. Тест: одна непрерывная последовательность.

Input: 
5  
3 4 5 6 7

Output:
3-7

   2. Тест: отрезки разной длины.

Input: 
7  
2 3 5 6 7 10 12

Output:
2-3 5-7 10 12

   3. Тест: последовательность из одного элемента.

Input:
1
41

Output:
41
