## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2501`

#### Выполнила: `Плакса Мария Антоновна`

#### Вариант: `15`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи
Задача 1.
> Ваша задача – посмотреть, какие значения принимает последовательность при разных a0 и n, вывести закономерность, по которой строится последовательность и запрограммировать ее самостоятельно.
>Ограничение сверху на n – искусственное, чтобы не упал весь сайт (а вы можете выбрать любое разумное ограничение самостоятельно). Если на ваш запрос сервер пятисотит (HTTP 500), значит ваша последовательность быстро растет, и питон сломался обрабатывать ее элементы, попробуйте вывести еще меньше элементов.

Для решения данной задачи необходимо проанализировать последовательность при разных a0 и n и вывести закономерность.

Задача 2.
>Дана последовательность из n целых чисел. Найти самую длинную подпоследовательность равных по модулю элементов, идущих подряд. Вывести ее длину и индекс первого элемента. Если таких подпоследовательностей несколько, выбрать ту, в которой знаки чисел чередуются (+ – + – или – + – +) дольше всего. Если и таких несколько, выбрать ту, которая встречается раньше остальных.

Для решения данной задачи необходимо проанализировать последовательность целых чисел и найти самую длинную непрерывную подпоследовательность элементов, равных по модулю. Для реализации необходимо совершить однократный проход по массиву с отслеживанием текущей подпоследовательности, удовлетворяющей условию равенства модулей. Одновременно отслеживается чередование знаков.

Задача 3.
>С клавиатуры вводится натуральное число N. Вывести на экран количество нечетных цифр в десятичном представлении числа.

Для решения данной задачи необходимо определить, сколько нечётных цифр содержится в десятичной записи натурального числа N , введённого с клавиатуры. Для этого будем последовательно извлекать цифры из числа и проверять на четность.

Задача 4.
>Дана возрастающая последовательность из n различных целых чисел. Требуется разбить её на непересекающиеся отрезки так, чтобы все числа из данной последовательности были покрыты этими отрезками ровно один раз, и чтобы не существовало числа, которое попало бы в какой-либо отрезок, но отсутствовало в исходной последовательности. Если отрезок содержит одно число – выведите только его, а если несколько – выведите границы через дефис (start-finish).

Для решения данной задачи необходимо группировать подряд идущие целые числа из заданной возрастающей последовательности в непрерывные отрезки, просмотреть последовательность и объединить в один отрезок те числа, которые образуют сплошной числовой интервал. Как только обнаруживается разрыв — то есть текущее число не следует сразу за предыдущим, — текущий отрезок завершается и начинается новый.

### 2. Входные и выходные данные

#### Данные на вход

Задача 1.

На вход программа должна получать 1 целое число и 1 натуральное число.

|             | Тип                       |min значение     | max значение   |
|-------------|---------------------------|-----------------|----------------|
| a0 (Число 1)| Целое  число              |-2<sup>31</sup>-1|2<sup>31</sup>-1|
| n (Число 2) | Целое положительное число | 1               |99              |

Задача 2.



#### Данные на выход

Так как программа должна вывести количество упавших доминошек, то на выход мы получим
единственное натуральное число, не превышающее 5.

|         | Тип                       | min значение | max значение|
|---------|---------------------------|--------------|-------------|
| Число 1 | Целое положительное число | 1            |5            |

### 3. Выбор структуры данных

Программа получает 6 натуральных чисел. Поэтому для их хранения
можно выделить 6 переменных (`x`, `a`, `b`, `c`, `d`, `e`) типа `int`, так как максимальное значение 2<sup>31</sup>-1 достаточно для любых реальных доминошек. Для подсчета количества упавших доминошек будем использовать переменную с названием `count` типа `int` с начальным значением 1.

|                | название переменной |Тип (в Java)| 
|----------------|---------------------|------------|
| X (Число 1)    | `x`                 | `int`      |
| A (Число 2)    | `a`                 | `int`      |
| B (Число 3)    | `b`                 | `int`      |
| C (Число 4)    | `c`                 | `int`      |
| D (Число 5)    | `d`                 | `int`      |
| E (Число 6)    | `e`                 | `int`      |
|count (Число 7) | `count`             | `int`      |


### 4. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает 6 целых чисел, обозначенных как `x`, `a`, `b`, `c`, `d`, `e`.

2. **Инициализация переменной**  
   Программа создает пременную, обозначенную как `count`, и присваивает ей начальное значение, равное 1.

3. **Проверка цепочки падения и вывод результата**
    - Если высота первой доминошки `a` больше или равна `x`, то доминошка `b` падает и `count` увеличивается на 1. Иначе на экран выводится значение переменной `count` и программа завершает проверку. 
    - Если высоты первой доминошки `a` и второй доминошки `b` больше или равны `x`, то доминошка `c` падает и `count` увеличивается на 1. Иначе на экран выводится значение переменной `count` и программа завершает проверку.
    - Если высоты первой доминошки `a`, второй доминошки `b`, третьей доминошки `c` больше или равны `x`, то доминошка `d` падает и `count` увеличивается на 1. Иначе на экран выводится значение переменной `count` и программа завершает проверку.
    - Если высоты первой доминошки `a`, второй доминошки `b`, третьей доминошки `c`, четвертой доминошки `d` больше или равны `x`, то доминошка `e` падает и `count` увеличивается на 1. Затем на экран выводится значение переменной `count`.

#### Блок-схема

```mermaid
graph TD
    A([Начало]) --> B[/Ввод: x, a, b, c, d, e/]
    B --> C[count = 1]
    C --> D{a >= x}
    D -- Нет --> E[/Вывод: 1/]
    D -- Да --> H[count = 2]
    H --> J{b >= x}
    J -- Да --> K[count = 3]
    J -- Нет --> I[/Вывод: 2/]
    K --> M{c >= x}
    M -- Нет --> L[/Вывод: 3/]
    M -- Да --> N[count = 4]
    N --> P{d >= x}
    P -- Нет --> O[/Вывод: 4/]
    P -- Да --> Q[count = 5]
    Q --> R[/Вывод: 5/]
    E --> S
    I --> S
    L --> S
    O --> S
    R --> S([Конец])

```

### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;

public class Main {
    // Объявляем объект класса Scanner для ввода данных
    public static Scanner in = new Scanner(System.in);
    // Объявляем объект класса PrintStream для вывода данных
    public static PrintStream out = System.out;

    public static void main(String[] args) {
        // Считывание шести целых чисел x, a, b, c, d, e из консоли
        int x = in.nextInt();
        int a = in.nextInt();
        int b = in.nextInt();
        int c = in.nextInt();
        int d = in.nextInt();
        int e = in.nextInt();
        int count = 1;


        // Сравнение a с расстоянием x
        if (a >= x) {
            // Если a больше или равно x, прибавляем к count единицу
            // Иначе выводим count
            count += 1;
            // Сравнение b с расстоянием x
            if (b >= x) {
                // Если b больше или равно x, прибавляем к count единицу
                // Иначе выводим count
                count += 1;
                // Сравнение c с расстоянием x
                if (c >= x) {
                    // Если c больше или равно x, прибавляем к count единицу
                    // Иначе выводим count
                    count += 1;
                    // Сравнение d с расстоянием x
                    if (d >= x) {
                        // Если d больше или равно x, прибавляем к count единицу, затем выводим получившееся значение count
                        count += 1;
                        out.println(count);
                    }
                    // Если d меньше x, то выводим count
                    else {
                        out.println(count);
                    }
                } else {
                    out.println(count);
                }
            } else {
                out.println(count);
            }
        } else {
                out.println(count);
            }
        }
    }
```

### 6. Анализ правильности решения
Рассмотрим несколько случаев:
1. Тест на `a >= x, b >= x, c < x`:

    - **Input**:
        ```
        4 5 4 3 5 2
        ```

    - **Output**:
        ```
        3
        ```

2. Тест на `a >= x, b < x`:

    - **Input**:
        ```
        5 5 4 6 5 6
        ```

    - **Output**:
        ```
        2
        ```

3. Тест на `a >= x, b >= x, c >= x, d < x`:

    - **Input**:
        ```
        3 4 5 3 2 3
        ```

    - **Output**:
        ```
        4
        ```

4. Тест на `a >= x, b >= x, c >= x, d >= x` (должны упасть все доминошки):

    - **Input**:
        ```
        10 11 10 12 10 9
        ```

    - **Output**:
        ```
        5
        ```

5. Тест на `a < x` (должна упасть только одна доминошка):

    - **Input**:
        ```
        3 2 3 4 5 2
        ```

    - **Output**:
        ```
        1
        ```
